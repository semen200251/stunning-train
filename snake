#include<GL/glut.h>
#include<stdio.h>
#include <stdlib.h>
#pragma warning(disable:4996)
#define SIZE_OF_ARRAY 60
//int restart = 0;
//int x = 240, y = 240;
//int time1 = 0;
//int time2 = 0;
//int count_block = SIZE_OF_ARRAY;
//float speed = 3;
//int score = 0;
//int polozhenie_apple_ax = 0;
//int polozhenie_apple_ay = 0;
//int napravlenie = 0;
//int ax=180, ay=180;
int num_button = 0;
int k = 0;
int back_keys = 0;
int count_keys = 1;
int status_botton = 0;
int count_key_status = 0;
int back_status = 0;
int status[15];
//void* font = GLUT_BITMAP_TIMES_ROMAN_24;
int d = 0;
int g = 0;
struct info_for_game
{
	int restart;
	int x;
	int y;
	int time1;
	int time2;
	int count_block;
	float speed;
	int score;
	int napravlenie;
	float kef;
};
struct info_for_game info_game = {0,240,240,0,0,SIZE_OF_ARRAY,3,0,3,1};
struct info_for_apple
{
	int count_apple;
	int count_red;
	int count_green;
	int count_blue;
};
struct info_for_apple info_apple =  { 0, 0, 0, 0 };
typedef struct 
{
	int x;
	int y;
	char Name[20];
	int Color[3];
	int HihlightColor[3];
	int status;
	int count_key;
}PNT;
PNT button[40];
typedef struct
{
	int ax;
	int ay;
	int status;
	int color[3];
}PNT1;
PNT1 apple[SIZE_OF_ARRAY];
typedef struct
{
	float ax;
	float ay;
}PNT2;
PNT2 snake[61];
int readLine(char** str, FILE* stream)
{
	int c = 0;
	int i = 0;
	int size = 50;

	*str = malloc(size);

	if (!(*str))
		return -1;

	while ((c = getc(stream)) != EOF && c != 26)
	{
		if (i >= size - 1)
		{
			char* l = realloc(*str, size + 50);

			size += 50;

			if (!l)
				return -1;
			*str = l;
		}

		if (c == '\n')
		{
			(*str)[i] = 0;
			return 0;
		}

		(*str)[i] = (char)c;
		i++;
	}

	(*str)[i] = 0;

	if (i)
		return 2;

	return 1;
}
int window_processing(char* str, int* posotion_window_x, int* posotion_window_y)
{
	unsigned int len = strlen(str);
	const char window[] = "WindowPosition=(";
	int a = 16;
	if (strstr(str, window))
	{
		if (isdigit(str[a]))
		{
			*posotion_window_x = atoi(str + a);
			while (isdigit(str[a]))
			{
				a++;
			}

			*posotion_window_y = atoi(str + a + 1);
		}
	}
	return 0;
}

int button_start(char* str)
{
	unsigned int len = strlen(str);
	const char button_position[] = "ButtonPosition=(";
	const char button_color[] = "Color=";
	const char button_hihlightColor[] = "Hihlightcolor=";
	const char button_name[] = "Name=";
	int d = 6;
	int g = 0;
	int v = 5;
	int z = 0;
	int e = 14;
	int a = 16;
	int b = 0;
	int q = 0;
	if (strstr(str, button_position))
	{
		if (isdigit(str[a]))
		{
			button[num_button].x = atoi(str + a);
			while (isdigit(str[a]))
			{
				a++;
			}
			button[num_button].y = atoi(str + a + 1);
		}
	}
	if (strstr(str, button_color))
	{
		for (int i = 0;i < 3;i++)
		{
			button[num_button].Color[g] = atoi(str + d);
			d += 4;
			g++;
		}
		g = 0;
	}
	if (strstr(str, button_name))
	{
		for (int i = v;i < strlen(str);i++)
		{
			button[num_button].Name[z] = str[i];
			z++;
		}
	}
	if (strstr(str, button_hihlightColor))
	{
		for (int i = 0;i < 3;i++)
		{
			button[num_button].HihlightColor[g] = atoi(str + e);
			e += 4;
			g++;
		}
	}
	if (isdigit(str[0]))
	{
		if (k == 0)
		{
			button[num_button].status = atoi(str);
			k = 1;
		}
		else
		{
			button[num_button].count_key = atoi(str);
			k = 0;
			num_button++;
		}
	}
	return 0;
}


void renderBitmapString(int h)
{
	int i;
	char simbol[100];
	_itoa(h, simbol, 10);
	char str1[] = "SCORE";
	char str2[] = "YOUR SCORE";
	if (status_botton != 3&& status_botton != 0)
	{
		glRasterPos2f(5, 460);
		for (i = 0;str1[i] != '\0';i++)
		{
			glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, str1[i]);
		}
		glRasterPos2f(100, 460);
		for (i = 0;simbol[i] != '\0';i++)
		{
			glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, simbol[i]);
		}
	}
	if (status_botton == 3)
	{
		glRasterPos2f(125,260);
		for (i = 0;str2[i] != '\0';i++)
		{
			glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, str2[i]);
		}
		glRasterPos2f(305, 260);
		for (i = 0;simbol[i] != '\0';i++)
		{
			glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, simbol[i]);
		}
	}
}
void renderBitmapString2(int x, int y, int h)
{
	glColor3d(button[h].HihlightColor[0], button[h].HihlightColor[1], button[h].HihlightColor[2]);
	glRasterPos2f(x, y);
	for (int i = 0;button[h].Name[i] != '\0';i++)
		glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, button[h].Name[i]);
}
void display()
{
	if (info_game.restart == 1)
	{
		 info_game.restart = 0;
		 info_game.x = 240, info_game.y = 240;
		 info_game.time1 = 0;
		 info_game.time2 = 0;
		 info_game.count_block = SIZE_OF_ARRAY;
		 info_apple.count_apple = 0;
		 info_apple.count_red = 0;
		 info_apple.count_blue = 0;
		 info_apple.count_green = 0;
		 info_game.speed = 3;
		 info_game.score = 0;
		 info_game.napravlenie = 1;
		 info_game.kef = 1;
		 for (int i = 0; i < info_game.count_block;i++)
		 {
			 snake[i].ax = info_game.x - 8 * i;
			 snake[i].ay = info_game.y;
		 }
	}
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	if (status_botton != 1)
	{
		glColor3f(255, 255, 255);
		glBegin(GL_POLYGON);
		glVertex2f(button[count_keys-1].x - 155, button[count_keys-1].y + 35);
		glVertex2f(button[count_keys-1].x - 155, button[count_keys-1].y - 35);
		glVertex2f(button[count_keys-1].x + 155, button[count_keys-1].y - 35);
		glVertex2f(button[count_keys-1].x + 155, button[count_keys-1].y + 35);
		glEnd();
		for (int i = 0;i < num_button;i++)
		{
			if (status_botton == button[i].status)
			{
				glColor3f(button[i].Color[0], button[i].Color[1], button[i].Color[2]);
				glBegin(GL_POLYGON);
				glVertex2f(button[i].x - 150, button[i].y + 30);
				glVertex2f(button[i].x - 150, button[i].y - 30);
				glVertex2f(button[i].x + 150, button[i].y - 30);
				glVertex2f(button[i].x + 150, button[i].y + 30);
				glColor3d(button[i].HihlightColor[0], button[i].HihlightColor[1], button[i].HihlightColor[2]);
				glEnd();
			}
		}
		for (int i = 0;i < num_button;i++)
		{
			if (status_botton == button[i].status)
			{
				renderBitmapString2(button[i].x - 50, button[i].y, i);
			}
		}
	}
	if (status_botton == 1)
	{
		renderBitmapString(info_game.score);
		if (info_game.napravlenie == 1)
		{
			for (int i = SIZE_OF_ARRAY - 2;i >= 0;i--)
			{
				snake[i + 1].ax = snake[i].ax;
				snake[i + 1].ay = snake[i].ay;
			}
			snake[0].ax += info_game.speed;
		}
		if (info_game.napravlenie == 2)
		{
			for (int i = SIZE_OF_ARRAY - 2;i >= 0;i--)
			{
				snake[i + 1].ax = snake[i].ax;
				snake[i + 1].ay = snake[i].ay;
			}
			snake[0].ax -= info_game.speed;
		}
		if (info_game.napravlenie == 3)
		{
			for (int i = SIZE_OF_ARRAY - 2;i >= 0;i--)
			{
				snake[i + 1].ax = snake[i].ax;
				snake[i + 1].ay = snake[i].ay;
			}
			snake[0].ay += info_game.speed;
		}
		if (info_game.napravlenie == 4)
		{
			for (int i = SIZE_OF_ARRAY - 2;i >= 0;i--)
			{
				snake[i + 1].ax = snake[i].ax;
				snake[i + 1].ay = snake[i].ay;
			}
			snake[0].ay -= info_game.speed;
		}
		if (snake[0].ax >= 480 || snake[0].ay >= 480 || snake[0].ax <= 0 || snake[0].ay <= 0)
		{
			status_botton = 3;
		}
		
		for (int d = 1;d < SIZE_OF_ARRAY;d++)
		{
			if (abs(snake[0].ax - snake[d].ax) < info_game.speed-1 && abs(snake[0].ay - snake[d].ay) < info_game.speed-1)
			{
				status_botton = 3;	
			}
		}
		for (int i = 0;i < info_apple.count_apple;i++)
		{

			if (abs(snake[0].ax - apple[i].ax) < 10 && abs(snake[0].ay - apple[i].ay) < 10)
			{
				if (apple[i].status == 0)
				{
					info_game.kef += 0.1;
					for (int d = i;d < info_apple.count_apple;d++)
					{
						apple[d] = apple[d + 1];
					}
					info_apple.count_apple--;
					info_apple.count_green--;
					info_game.speed += 0.05;
					//info_game.count_block+=3;
					info_game.score++;
					break;
				}
				if (apple[i].status == 1)
				{
					info_game.kef += 0.3;
					for (int d = i;d < info_apple.count_apple;d++)
					{
						apple[d] = apple[d + 1];
					}
					info_apple.count_apple--;
					info_apple.count_red--;
					info_game.speed += 3;
					break;
				}
				if (apple[i].status == 2)
				{
					//info_game.count_block++;
					for (int d = i;d < info_apple.count_apple;d++)
					{
						apple[d] = apple[d + 1];
					}
					info_apple.count_apple--;
					info_apple.count_blue--;
					info_game.speed -= 0.5;
					break;
				}
			}
		}
		if (info_game.time1 % 107 == 0 && info_game.time1 != info_game.time2)
		{
			info_game.time2 = info_game.time1;
			int polozhenie_nuzhnogo_apple = 0;
			//polozhenie_apple_ax = rand() % 480;
			//polozhenie_apple_ay = rand() % 480;
			apple[info_apple.count_apple].ax = rand() % 480;
			apple[info_apple.count_apple].ay = rand() % 480;
			apple[info_apple.count_apple].status = 0;
			apple[ info_apple.count_apple].color[0] = 0;
			apple[info_apple.count_apple].color[1] = 1;
			apple [info_apple.count_apple].color[2] = 0;
			info_apple.count_apple++;
			info_apple.count_green++;
			if (info_apple.count_green > 4)
			{
				for (int i = 0;i < info_apple.count_apple;i++)
				{
					if (apple[i].status == 0)
					{
						polozhenie_nuzhnogo_apple = i;
						break;
					}

				}
				for (int i = polozhenie_nuzhnogo_apple;i < info_apple.count_apple;i++)
				{
					apple[i] = apple[i + 1];
				}
			}
			info_game.speed += 0.01;
		}
		if (info_game.time1 % 383 == 0 && info_game.time1 != info_game.time2)
		{
			info_game.time2 = info_game.time1;
			int polozhenie_nuzhnogo_apple = 0;
			//polozhenie_apple_ax = rand() % 480;
			//polozhenie_apple_ay = rand() % 480;
			apple[info_apple.count_apple].ax = rand() % 480;
			apple[info_apple.count_apple].ay = rand() % 480;
			apple[info_apple.count_apple].status = 1;
			apple[ info_apple.count_apple].color[0] = 1;
			apple[info_apple.count_apple].color[1] = 0;
			apple[info_apple.count_apple].color[2] = 0;
			info_apple.count_apple++;
			info_apple.count_red++;
			if (info_apple.count_red > 3)
			{
				for (int i = 0;i < info_apple.count_apple;i++)
				{
					if (apple[i].status == 1)
					{
						polozhenie_nuzhnogo_apple = i;
						break;
					}

				}
				for (int i = polozhenie_nuzhnogo_apple;i < info_apple.count_apple;i++)
				{
					apple[i] = apple[i + 1];
				}
			}
		}
		if (info_game.time1 % 1327 == 0 && info_game.time1 != info_game.time2)
		{
			info_game.time2 = info_game.time1;
			int polozhenie_nuzhnogo_apple = 0;
			//polozhenie_apple_ax = rand() % 480;
			//polozhenie_apple_ay = rand() % 480;
			apple[info_apple.count_apple].ax = rand() % 480;
			apple[info_apple.count_apple].ay = rand() % 480;
			apple[info_apple.count_apple].status = 2;
			apple[info_apple.count_apple].color[0] = 0;
			apple[ info_apple.count_apple].color[1] = 0;
			apple[info_apple.count_apple].color[2] = 1;
			info_apple.count_apple++;
			info_apple.count_blue++;
			if (info_apple.count_blue > 3)
			{
				for (int i = 0;i < info_apple.count_apple;i++)
				{
					if (apple[i].status == 2)
					{
						polozhenie_nuzhnogo_apple = i;
						break;
					}

				}
				for (int i = polozhenie_nuzhnogo_apple;i < info_apple.count_apple;i++)
				{
					apple[i] = apple[i + 1];
				}
			}
		}
		for (int i = 0;i < info_apple.count_apple;i++)
		{
			glPointSize(10);
			glColor3f(apple[i].color[0], apple[i].color[1], apple[i].color[2]);
			glBegin(GL_POINTS);
			glVertex2f(apple[i].ax, apple[i].ay);
			glEnd();
		}
		glPointSize(16);
		glColor3f(1, 0, 0);
		for (int i = 0;i < info_game.count_block;i++)
		{
			glColor3f(1, 0, 0);
			glBegin(GL_POLYGON);
			glVertex2f(snake[i].ax + 8, snake[i].ay + 8);
			glVertex2f(snake[i].ax - 8, snake[i].ay + 8);
			glVertex2f(snake[i].ax - 8, snake[i].ay - 8);
			glVertex2f(snake[i].ax + 8, snake[i].ay - 8);
			glEnd();
		}
	}
	renderBitmapString(info_game.score);
	glutSwapBuffers();
	
}
void processSpecialKeys(int key, int xx, int yy)
{
	int a=0;
	int b=0;
	for (int i = 0;i < num_button;i++)
	{
		if (button[i].status == status_botton)
		{
			a = button[i].count_key;
			if (g == 0)
			{
				count_keys = a;
			}
			break;
		}
	}
	for (int i = 0;i < num_button;i++)
	{
		if (button[i].status == status_botton)
		{
			b = button[i].count_key;
		}
	}
	switch (key)
	{
	case GLUT_KEY_RIGHT:
		if (status_botton != 1)
		{
			if (status_botton == 3&& count_keys!=4)
			{
				status_botton = 1;
				info_game.restart = 1;
				info_game.napravlenie = 1;
				break;
			}
			//count_keys++;
			g = 1;
			if (count_keys > b)
				count_keys = b;
			status[d] = status_botton;
			info_game.restart = 1;
			g = 0;
			d++;
			status_botton = button[count_keys-1].count_key;
			if (status_botton == 2|| count_keys == 4)
			{
				exit(0);
			}
			display();
		}
		if (status_botton == 1)
		{
			info_game.napravlenie = 1;
			display();
		}
		break;
	case GLUT_KEY_UP:
		if (status_botton != 1)
		{
			count_keys--;
			g = 1;
			if (count_keys < a)
				count_keys = a;
		}
		if (status_botton == 1)
		{
			info_game.napravlenie = 3;
			display();
		}
		break;
	case GLUT_KEY_DOWN:
		if (status_botton != 1)
		{
			count_keys++;
			g = 1;
			if (count_keys > b)
				count_keys = b;
		}
		if (status_botton == 1)
		{
			info_game.napravlenie = 4;
			display();
		}
		break;
	case GLUT_KEY_LEFT:
		if (status_botton != 1)
		{
			status[d] = 0;
			g = 0;
			d--;
			count_keys = back_keys;
			status_botton = status[d];
			display();
		}
		if (status_botton == 1)
		{
			info_game.napravlenie = 2;
			display();
		}
		break;
	}
}



void timf(int value)
{
	glutPostRedisplay();
	display();
	info_game.time1++;
	glutTimerFunc(40, timf, 0);
}





int main(int* argc, char** argv)
{
	int posotion_window_x = 0;
	int posotion_window_y = 0;
	int status_botton = 0;
	int count_botton = 1;
	FILE* stream = stdin;
	/*if (argc > 1)
	{
		if (fopen_s(&stream, argv[1], "r"))
			return 1;
	}*/
	fopen_s(&stream, "menu.txt", "r");
	char* str = NULL;
	int var = 0;
	while (!var)
	{
		var = readLine(&str, stream);
		if (var == 1)
		{
			free(str);
			break;
		}
		window_processing(str, &posotion_window_x, &posotion_window_y);
		button_start(str);
		free(str);
	}
	/*for (int i = 0; i < SIZE_OF_ARRAY;i++)
	{
		snake[i].ax = x - 8 * i;
		snake[i].ay = y;

	}*/
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
	glutInitWindowSize(480, 480);
	glutInitWindowPosition(200, 200);
	glViewport(0, 0, 480, 480);
	glutCreateWindow("Snake");
	gluOrtho2D(0, 480, 0, 480);
	glutDisplayFunc(display);
	glutSpecialFunc(processSpecialKeys);
	glutTimerFunc(10, timf, 0);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	/*glutReshapeFunc(reshape);*/
	glutMainLoop();
	return 1;
}
